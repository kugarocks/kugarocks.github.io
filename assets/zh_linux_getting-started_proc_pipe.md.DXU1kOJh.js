import{_ as e,c as i,o as s,ah as l}from"./chunks/framework.HzbgFGQH.js";const k=JSON.parse('{"title":"管道","description":"","frontmatter":{},"headers":[],"relativePath":"zh/linux/getting-started/proc/pipe.md","filePath":"zh/linux/getting-started/proc/pipe.md","lastUpdated":1746728954000}'),t={name:"zh/linux/getting-started/proc/pipe.md"};function r(h,a,d,n,o,c){return s(),i("div",null,a[0]||(a[0]=[l('<h1 id="管道" tabindex="-1">管道 <a class="header-anchor" href="#管道" aria-label="Permalink to “管道”">​</a></h1><h2 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to “基本概念”">​</a></h2><p>管道可以把一个命令的输出作为下一个命令的输入， 在命令行环境中通过符号 <code>|</code> 来表示，是一种进程间的单向通信形式，基于文件描述符实现。</p><h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to “工作原理”">​</a></h2><p>管道会创建了内存缓冲区，两个进程（命令）通过这个缓冲区通信。</p><h3 id="创建管道" tabindex="-1">创建管道 <a class="header-anchor" href="#创建管道" aria-label="Permalink to “创建管道”">​</a></h3><p>使用 <code>|</code> 创建管道时，Shell 会调 <code>pipe()</code> 来创建管道，包含两个文件描述符。</p><ul><li>写入端文件描述符：<code>A</code>。</li><li>读取端文件描述符：<code>B</code>。</li></ul><h3 id="命令连接" tabindex="-1">命令连接 <a class="header-anchor" href="#命令连接" aria-label="Permalink to “命令连接”">​</a></h3><ul><li>左侧命令：把标准输出（文件描述符 <code>1</code>）重定向到管道的写入端 <code>A</code><strong>。</strong></li><li>右侧命令：把标准输入（文件描述符 <code>0</code>）重定向到管道的读取端 <code>B</code><strong>。</strong></li></ul><h3 id="数据流动" tabindex="-1">数据流动 <a class="header-anchor" href="#数据流动" aria-label="Permalink to “数据流动”">​</a></h3><ul><li>实时数据传输：两边的命令会并行执行，不会等前一个命令结束。</li><li>无临时文件：数据在内存中传递。</li><li>缓冲区大小：取决于系统。</li></ul><h2 id="查看缓冲区大小" tabindex="-1">查看缓冲区大小 <a class="header-anchor" href="#查看缓冲区大小" aria-label="Permalink to “查看缓冲区大小”">​</a></h2><div class="language-bash"><button title="复制代码" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sys/fs/pipe-max-size</span></span></code></pre></div><div class="language-bash"><button title="复制代码" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1048576</span></span></code></pre></div><h2 id="局限性" tabindex="-1">局限性 <a class="header-anchor" href="#局限性" aria-label="Permalink to “局限性”">​</a></h2><ul><li>单向通信：双向通信需要使用其他机制，如命名管道（FIFO）或套接字。</li><li>缓冲区大小：如果缓冲区满了，上游命令会暂停。</li></ul>',17)]))}const b=e(t,[["render",r]]);export{k as __pageData,b as default};
