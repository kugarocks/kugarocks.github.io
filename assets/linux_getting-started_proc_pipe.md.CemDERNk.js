import{_ as i,c as a,o as t,ah as s}from"./chunks/framework.HzbgFGQH.js";const m=JSON.parse('{"title":"Pipe","description":"","frontmatter":{},"headers":[],"relativePath":"linux/getting-started/proc/pipe.md","filePath":"en/linux/getting-started/proc/pipe.md","lastUpdated":1746813098000}'),n={name:"linux/getting-started/proc/pipe.md"};function o(r,e,l,c,d,h){return t(),a("div",null,e[0]||(e[0]=[s('<h1 id="pipe" tabindex="-1">Pipe <a class="header-anchor" href="#pipe" aria-label="Permalink to “Pipe”">​</a></h1><h2 id="basic-concepts" tabindex="-1">Basic Concepts <a class="header-anchor" href="#basic-concepts" aria-label="Permalink to “Basic Concepts”">​</a></h2><p>A pipe can use the output of one command as the input of the next command, represented by the symbol <code>|</code> in the command-line environment, which is a form of one-way communication between processes, implemented based on file descriptors.</p><h2 id="working-principle" tabindex="-1">Working Principle <a class="header-anchor" href="#working-principle" aria-label="Permalink to “Working Principle”">​</a></h2><p>A pipe creates a memory buffer, and two processes (commands) communicate through this buffer.</p><h3 id="creating-a-pipe" tabindex="-1">Creating a Pipe <a class="header-anchor" href="#creating-a-pipe" aria-label="Permalink to “Creating a Pipe”">​</a></h3><p>When creating a pipe using <code>|</code>, the Shell calls <code>pipe()</code> to create the pipe, which includes two file descriptors.</p><ul><li>Write-end file descriptor: <code>A</code>.</li><li>Read-end file descriptor: <code>B</code>.</li></ul><h3 id="command-connection" tabindex="-1">Command Connection <a class="header-anchor" href="#command-connection" aria-label="Permalink to “Command Connection”">​</a></h3><ul><li>Left command: Redirects the standard output (file descriptor <code>1</code>) to the write-end <code>A</code> of the pipe.</li><li>Right command: Redirects the standard input (file descriptor <code>0</code>) to the read-end <code>B</code> of the pipe.</li></ul><h3 id="data-flow" tabindex="-1">Data Flow <a class="header-anchor" href="#data-flow" aria-label="Permalink to “Data Flow”">​</a></h3><ul><li>Real-time data transmission: The commands on both sides execute in parallel, without waiting for the previous command to finish.</li><li>No temporary files: Data is transmitted in memory.</li><li>Buffer size: Depends on the system.</li></ul><h2 id="buffer-size" tabindex="-1">Buffer Size <a class="header-anchor" href="#buffer-size" aria-label="Permalink to “Buffer Size”">​</a></h2><div class="language-bash"><button title="Copy code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cat</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /proc/sys/fs/pipe-max-size</span></span></code></pre></div><div class="language-bash"><button title="Copy code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1048576</span></span></code></pre></div><h2 id="limitations" tabindex="-1">Limitations <a class="header-anchor" href="#limitations" aria-label="Permalink to “Limitations”">​</a></h2><ul><li>One-way communication: Two-way communication requires the use of other mechanisms, such as named pipes (FIFO) or sockets.</li><li>Buffer size: If the buffer is full, the upstream command will pause.</li></ul>',17)]))}const f=i(n,[["render",o]]);export{m as __pageData,f as default};
